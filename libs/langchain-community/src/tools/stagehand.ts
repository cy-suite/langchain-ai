import { CallbackManagerForToolRun } from "@langchain/core/callbacks/manager";
import { Tool, type ToolParams } from "@langchain/core/tools";
import { getEnvironmentVariable } from "@langchain/core/utils/env";
<<<<<<< HEAD
import { Stagehand } from "@browserbasehq/stagehand";
export { BaseToolkit as Toolkit } from "@langchain/core/tools";
import { z } from "zod";

//  Documentation is here:
//  https://js.langchain.com/docs/integrations/tools/stagehand
=======

// TODO create a TOOLKIT for stagehand

import { Tool, ToolInterface } from "@langchain/core/tools";
import { Toolkit } from "../base.js";
import { ConneryService } from "../../../tools/connery.js";
>>>>>>> parent of 6cb4ed204 (clean up)

/**
 * ConneryToolkit provides access to all the available actions from the Connery Runner.
 * @extends Toolkit
 */
export class StagehandToolkit extends Toolkit {
  tools: ToolInterface[];
  stagehand?: Stagehand;

  constructor(stagehand?: Stagehand) {
    super();
    this.stagehand = stagehand;
    this.tools = this.initializeTools();
  }

  private initializeTools(): ToolInterface[] {
    return [
      new StagehandActTool(this.stagehand),
      new StagehandExtractTool(this.stagehand),
      new StagehandObserveTool(this.stagehand)
    ];
  }

  static async fromStagehand(stagehand: Stagehand): Promise<StagehandToolkit> {
    return new StagehandToolkit(stagehand);
  }
}

<<<<<<< HEAD
=======

/**
 * Tavily search API tool integration.
 *
 * Setup:
 * Install `@langchain/community`. You'll also need an API key set as `TAVILY_API_KEY`.
 *
 * ```bash
 * npm install @langchain/community
 * ```
 *
 * ## [Constructor args](https://api.js.langchain.com/classes/_langchain_community.tools_tavily_search.TavilySearchResults.html#constructor)
 *
 * <details open>
 * <summary><strong>Instantiate</strong></summary>
 *
 * ```typescript
 * import { TavilySearchResults } from "@langchain/community/tools/tavily_search";
 *
 * const tool = new TavilySearchResults({
 *   maxResults: 2,
 *   // ...
 * });
 * ```
 * </details>
 *
 * <br />
 *
 * <details>
 *
 * <summary><strong>Invocation</strong></summary>
 *
 * ```typescript
 * await tool.invoke("what is the current weather in sf?");
 * ```
 * </details>
 *
 * <br />
 *
 * <details>
 *
 * <summary><strong>Invocation with tool call</strong></summary>
 *
 * ```typescript
 * // This is usually generated by a model, but we'll create a tool call directly for demo purposes.
 * const modelGeneratedToolCall = {
 *   args: {
 *     input: "what is the current weather in sf?",
 *   },
 *   id: "tool_call_id",
 *   name: tool.name,
 *   type: "tool_call",
 * };
 * await tool.invoke(modelGeneratedToolCall);
 * ```
 *
 * ```text
 * ToolMessage {
 *   "content": "...",
 *   "name": "tavily_search_results_json",
 *   "additional_kwargs": {},
 *   "response_metadata": {},
 *   "tool_call_id": "tool_call_id"
 * }
 * ```
 * </details>
 */

// ACT TOOL
import { Tool } from "@langchain/core/tools";
import { Stagehand } from "@browserbasehq/stagehand";

>>>>>>> parent of 6cb4ed204 (clean up)
export class StagehandActTool extends Tool {
  name = "stagehand_act";
  description = "Use this tool to perform an action on the current web page using Stagehand. The input should be a string describing the action to perform.";
  private stagehand?: Stagehand;
  private localStagehand?: Stagehand;

  constructor(stagehandInstance?: Stagehand) {
    super();
    this.stagehand = stagehandInstance;
  }

  private async getStagehand(): Promise<Stagehand> {
    if (this.stagehand) return this.stagehand;
    
    if (!this.localStagehand) {
      this.localStagehand = new Stagehand({
        env: "LOCAL",
        enableCaching: true,
      });
      await this.localStagehand.init();
    }
    return this.localStagehand;
  }

  async _call(input: string): Promise<string> {
    const stagehand = await this.getStagehand();
    const result = await stagehand.act({ action: input });
    if (result.success) {
      return `Action performed successfully: ${result.message}`;
    } else {
      return `Failed to perform action: ${result.message}`;
    }
  }
}

<<<<<<< HEAD
=======
// extract

import { Tool } from "@langchain/core/tools";
import { Stagehand } from "@browserbasehq/stagehand";
import { z } from "zod";

>>>>>>> parent of 6cb4ed204 (clean up)
export class StagehandExtractTool extends Tool {
  name = "stagehand_extract";
  description = "Use this tool to extract structured information from the current web page using Stagehand. The input should be a JSON string with 'instruction' and 'schema' fields.";
  private stagehand?: Stagehand;
  private localStagehand?: Stagehand;

  constructor(stagehandInstance?: Stagehand) {
    super();
    this.stagehand = stagehandInstance;
  }

  private async getStagehand(): Promise<Stagehand> {
    if (this.stagehand) return this.stagehand;
    
    if (!this.localStagehand) {
      this.localStagehand = new Stagehand({
        env: "LOCAL",
        enableCaching: true,
      });
      await this.localStagehand.init();
    }
    return this.localStagehand;
  }

  async _call(input: string): Promise<string> {
    const stagehand = await this.getStagehand();

    let parsedInput;
    try {
      parsedInput = JSON.parse(input);
    } catch (error) {
      return `Invalid input. Please provide a JSON string with 'instruction' and 'schema' fields.`;
    }

    const { instruction, schema } = parsedInput;

    if (!instruction || !schema) {
      return `Input must contain 'instruction' and 'schema' fields.`;
    }

    try {
      const result = await stagehand.extract({
        instruction,
        schema: z.object(schema)
      });
      return JSON.stringify(result);
    } catch (error) {
      return `Failed to extract information: ${error.message}`;
    }
  }
}

<<<<<<< HEAD
=======
// OBSERVE TOOL

import { Tool } from "@langchain/core/tools";
import { Stagehand } from "@browserbasehq/stagehand";

>>>>>>> parent of 6cb4ed204 (clean up)
export class StagehandObserveTool extends Tool {
  name = "stagehand_observe";
  description = "Use this tool to observe the current web page and retrieve possible actions using Stagehand. The input can be an optional instruction string.";
  private stagehand?: Stagehand;
  private localStagehand?: Stagehand;

  constructor(stagehandInstance?: Stagehand) {
    super();
    this.stagehand = stagehandInstance;
  }

  private async getStagehand(): Promise<Stagehand> {
    if (this.stagehand) return this.stagehand;
    
    if (!this.localStagehand) {
      this.localStagehand = new Stagehand({
        env: "LOCAL",
        enableCaching: true,
      });
      await this.localStagehand.init();
    }
    return this.localStagehand;
  }

  async _call(input: string): Promise<string> {
    const stagehand = await this.getStagehand();
    const instruction = input || undefined;

    try {
      const result = await stagehand.observe({ instruction });
      return JSON.stringify(result);
    } catch (error) {
      return `Failed to observe page: ${error.message}`;
    }
  }
}